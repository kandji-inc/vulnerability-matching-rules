import argparse
import os
import orjson
from pydantic import ValidationError

from pydantic_model import *
from pprint import pprint


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("rules_path")
    parser.add_argument("schema_path")
    args = parser.parse_args()

    rules = []
    invalid_json_rules = []
    invalid_pydantic_rules = []
    duplicate_rules = []

    # load rules and make sure json is valid
    for subdir, dirs, files in os.walk(args.rules_path):
        for file in files:
            with open(os.path.join(subdir, file)) as f:
                try:
                    rules.append((orjson.loads(f.read()), os.path.join(subdir, file)))
                except orjson.JSONDecodeError as e:
                    invalid_json_rules.append({os.path.join(subdir, file): str(e)})

    rules_check = []
    # check rules against pydantic
    for r, f in rules:
        try:
            pydantic_obj = VulnerabilityMatchingRule.parse_obj(r)
            found_existing_rule = False
            for existing_rule_tuple in rules_check:
                if pydantic_obj == existing_rule_tuple[0]:
                    duplicate_rules.append({f: f"Rule is a duplicate of rule {existing_rule_tuple[1]}"})
                    found_existing_rule = True

            if not found_existing_rule:
                rules_check.append((pydantic_obj, f))
        except ValidationError as e:
            invalid_pydantic_rules.append({f: str(e)})

    if any([invalid_json_rules, invalid_pydantic_rules, duplicate_rules]):
        print("Rules with invalid JSON structure:")
        pprint(invalid_json_rules)
        print("Rules that are rejected by VulnerabilityMatchingRule pydantic model:")
        pprint(invalid_pydantic_rules)
        print("Duplicate rules:")
        pprint(duplicate_rules)
        exit(1)


if __name__ == "__main__":
    main()
